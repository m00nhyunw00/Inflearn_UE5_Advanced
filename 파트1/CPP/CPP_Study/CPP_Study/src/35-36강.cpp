#include <iostream>
using namespace std;

// 오늘의 주제 : 포인터

void SetHp(int* hp)
{
	*hp = 100;
}

int main() 
{
	int hp = 1;
	SetHp(&hp);

	int number = 1;

	// TYPE* 변수이름;
	
	// 바구니는 바구니인데...
	// [주소를 저장하는 바구니다!]
	// 변수 선언할 때 * 등장했다 -> 포인터 == 주소

	int* ptr = &number;	// &변수이름 == 변수의 주소값
						// 포인터 변수 크기는 4바이트(x86, 즉 32비트 체계) or 8바이트(x64, 즉 64비트 체계) 고정

	// 근데 남의 주소를 갖고 뭘 하라는거지?
	// 추가 문법 : [주소를 저장하는 바구니]가 가리키는 주소로 가서 무엇인가를 해라!
	
	// *변수이름 == [변수이름] 값을 가진 주소에 저장되어있는 값;
	
	// * 붙은 것은 포탈을 타고 순간이동한다고 생각하자
	// - 변수 선언 : 포탈을 만든다
	// - 사용할 때 : 포탈을 탄다

	cout << *ptr << endl;

	int value1 = *ptr;	// 결과값 1
	*ptr = 2;

	cout << *ptr << endl;	// 결과값 2

	// TYPE은 왜 붙여줄까? 크기도 고정인데??
	// * == 포인터의 의미 == 주소를 저장하는 바구니

	// 주소에 가면 뭐가 있는데?
	// ex) 결혼식 청첩장에 있는 주소 = =예식장 주소
	// ex) 명함에 있는 주소 == 회사 주소
	// 해당 주소값에 갔을 때, 해당 주소에 저장되어 있는 데이터의 타입을 사전에 알리는 용도
	// 해당 주소로 가서 몇바이트로 끊어서 어떤 방식으로 데이터를 이해해야되는지 컴퓨터에게 알림
	// 원래 데이터는 읽는 방식에 따라서 다른 값을 가질 수 있음

	// 타입의 불일치
	__int64* ptr2 = (__int64*)& number;

	*ptr2 = 0xAABBCCDDEEFF;
	// 위와 같은 상황에서는 실제로 ptr 주소값을 가진 변수인 number는 int 타입이므로,
	// - ptr2 주소에 4바이트인 CCDDEEFF만 저장되고, 다음 주소값에 0000AABB가 저장되어 값이 덮어씌워질 수 있음
	// - 애초에 타입 불일치로 에러 발생함

	return 0;
}